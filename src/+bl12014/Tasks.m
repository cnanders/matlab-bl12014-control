classdef Tasks < mic.Base
        
    properties (Constant)
       
        cRecipeM142Default = 'Serpentine_sigx25_numx9_offx0_sigy5_numy5_offy0_scale1_per20_filthz2000_dt24_20181219-150012-gridified-repeat.mat';
        dMotMinWCX = 4
        dMotMinWCY = 4
        dMotMinRCX = 4
        dMotMinRCY = 4
        dMotMinLSI = 4
    end
    
	properties
        
       
    end
    
    properties (SetAccess = private)
        
        
        
    end
    
    properties (Access = private)
                    
        
        
        
       
    end
    
        
    events
        
        
    end
    

    
    methods
        
        
        function this = Tasks()
            
                        
            
        end
        
    end
    
    methods (Static)
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.TuneFluxDensity}
        % @param {mic.Clock 1x1}
        
        function task = createStateUndulatorIsCalibrated(cName, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if  ~isa(ui, 'bl12014.ui.TuneFluxDensity')  && ...
                ~isa(ui, 'bl12014.ui.DCTFluxDensity')
                error('ui must be bl12014.ui.*FluxDensity');
            end
            
            dTolerance = 0.02;
            ceTasks = {
                mic.Task.fromUiGetSetNumberWithGoalGetter(...
                    ui.uiUndulator.uiGap, ... mic.ui.device.GetSetNumbern
                    @() ui.getGapOfUndulatorCalibrated(), ... goal getter
                    dTolerance, ... Tolerance
                    'mm', ... Unit
                    'Gap of Undulator' ...
                ), ...
            };

            fhGetMessage = @() [...
                'Gap of Undulator @CalVal ', ...
                sprintf('(%1.2f mm +/- %1.2f)', ui.getGapOfUndulatorCalibrated(), dTolerance) ...
            ];
        
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        function task = createStateDCTApertureIsCalibrated(cName, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if  ~isa(ui, 'bl12014.ui.DCTFluxDensity')
                error('ui must be bl12014.ui.DCTFluxDensity');
            end
            
            
            task = mic.Task(...
               'fhExecute', @() ui.uiDiode.uiPopupAperture.setSelectedByLabel(ui.getApertureCalibrated()), ...
               'fhIsDone', @() strcmpi(ui.getApertureCalibrated(), ui.uiDiode.uiPopupAperture.get().cLabel), ...
               'fhGetMessage', @() sprintf('Setting aperture to %s', ui.getApertureCalibrated()) ...
            );
            
            ceTasks = {
                task
            };

            fhGetMessage = @() [...
                'Aperture @CalVal ', ...
                sprintf('(%s)', ui.getApertureCalibrated()) ...
            ];
        
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        
        
        
        function d = getXOfApertureOfDCTFluxCalibration(uiFluxDensity)
            ceOptions = uiFluxDensity.uiDiode.uiPopupAperture.getOptions();
            for n = 1 : length(ceOptions)
               if strcmpi(ceOptions{n}.cLabel, uiFluxDensity.getApertureCalibrated())
                   d = ceOptions{n}.dX;
                   return
               end
           end
        end
        
        function d = getYOfApertureOfDCTFluxCalibration(uiFluxDensity)
            ceOptions = uiFluxDensity.uiDiode.uiPopupAperture.getOptions();
            for n = 1 : length(ceOptions)
               if strcmpi(ceOptions{n}.cLabel, uiFluxDensity.getApertureCalibrated())
                   d = ceOptions{n}.dY;
                   return
               end
           end
        end
        
        
        function task = createStateDCTApertureStageIsCalibrated(cName, uiStage, uiFluxDensity, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if  ~isa(uiStage, 'bl12014.ui.DCTApertureStage') 
                error('uiStage must be bl12014.ui.DCTApertureStage');
            end
            
            if  ~isa(uiFluxDensity, 'bl12014.ui.DCTFluxDensity')
                error('uiFluxDensity must be bl12014.ui.DCTFluxDensity');
            end
            
            dTolerance = 0.02;
            
            

            ceTasks = {
                mic.Task.fromUiGetSetNumberWithGoalGetter(...
                    uiStage.uiX, ... mic.ui.device.GetSetNumbern
                    @() bl12014.Tasks.getXOfApertureOfDCTFluxCalibration(uiFluxDensity), ... goal getter
                    dTolerance, ... Tolerance
                    'mm', ... Unit
                    'X of Aperture Stage' ...
                ), ...
                mic.Task.fromUiGetSetNumberWithGoalGetter(...
                    uiStage.uiY, ... mic.ui.device.GetSetNumbern
                    @() bl12014.Tasks.getYOfApertureOfDCTFluxCalibration(uiFluxDensity), ... goal getter
                    dTolerance, ... Tolerance
                    'mm', ... Unit
                    'Y of Aperture Stage' ...
                ), ...
                bl12014.Tasks.createStateDCTApertureIsCalibrated(...
                    [cName, 'diode-aperture-setting-is-calibrated'], ...
                    uiFluxDensity, ...
                    clock ...
               ) ...
            };

            fhGetMessage = @() [...
                'Aperture @CalVal ', ...
                sprintf('(%s) ', uiFluxDensity.getApertureCalibrated()), ...
                sprintf('(stage x=%1.2f y=%1.2f) ', ...
                    bl12014.Tasks.getXOfApertureOfDCTFluxCalibration(uiFluxDensity), ...
                    bl12014.Tasks.getYOfApertureOfDCTFluxCalibration(uiFluxDensity) ...
                ) ...
            ];
        
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        function task = createStateDCTApertureStageMatchesDiode(cName, uiStage, uiDiode, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if  ~isa(uiStage, 'bl12014.ui.DCTApertureStage') 
                error('uiStage must be bl12014.ui.DCTApertureStage');
            end
            
            if  ~isa(uiDiode, 'bl12014.ui.DCTDiode') 
                error('uiStage must be bl12014.ui.DCTDiode');
            end
            
            dTolerance = 0.02;
            
            ceTasks = {
                mic.Task.fromUiGetSetNumberWithGoalGetter(...
                    uiStage.uiX, ... mic.ui.device.GetSetNumbern
                    @() uiDiode.uiPopupAperture.get().dX, ... goal getter
                    dTolerance, ... Tolerance
                    'mm', ... Unit
                    'X of Aperture' ...
                ), ...
                mic.Task.fromUiGetSetNumberWithGoalGetter(...
                    uiStage.uiY, ... mic.ui.device.GetSetNumbern
                    @() uiDiode.uiPopupAperture.get().dY, ... goal getter
                    dTolerance, ... Tolerance
                    'mm', ... Unit
                    'Y of Aperture' ...
                ), ...
            };

            fhGetMessage = @() [...
                'Aperture Stage at Selected Diode Aperture ', ...
                sprintf('(%s) ', uiDiode.uiPopupAperture.get().cLabel), ...
                sprintf('x=%1.2f y=%1.2f ', ...
                    uiDiode.uiPopupAperture.get().dX, ...
                    uiDiode.uiPopupAperture.get().dY ...
                ) ...
            ];
        
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        function task = createStatePowerPmacAccelSetForFEM(cName, hardware, clock)
            
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            dTol = 5;
            
            dVal = 100;
            taskTAW = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setAccelOfWaferCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getAccelOfWaferCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TA Wafer Hydra %1.0f', dVal) ...
            );
        
            taskTAR = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setAccelOfReticleCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getAccelOfReticleCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TA Reticle Hyrda %1.0f', dVal) ...
            );
        
            dVal = 1000;
            taskTSW = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setDecelOfWaferCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getDecelOfWaferCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TS Wafer Hydra %1.0f', dVal) ...
            );
        
            taskTSR = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setDecelOfReticleCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getDecelOfReticleCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TS Reticle Hydra %1.0f', dVal) ...
            );
        
            ceTasks = {...
                taskTAW, ...
                taskTAR, ...
                taskTSW, ...
                taskTSR ...
            };
        
            fhGetMessage = @() [...
                'Accel set for FEM: ', ...
                sprintf('TA W %1.0f, ', hardware.getDeltaTauPowerPmac().getAccelOfWaferCoarse()), ...
                sprintf('TA R %1.0f, ', hardware.getDeltaTauPowerPmac().getAccelOfReticleCoarse()), ...
                sprintf('TS W %1.0f, ', hardware.getDeltaTauPowerPmac().getDecelOfWaferCoarse()), ...
                sprintf('TS R %1.0f ', hardware.getDeltaTauPowerPmac().getDecelOfReticleCoarse()) ...
            ];
        
             task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
        end
        
        function task = createStatePowerPmacAccelSetToDefault(cName, hardware, clock)
            
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            dTol = 5;
            
            dVal = 100;
            taskTAW = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setAccelOfWaferCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getAccelOfWaferCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Set TA Wafer Hydra %1.0f', dVal) ...
            );
        
            taskTAR = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setAccelOfReticleCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getAccelOfReticleCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TA Reticle Hyrda %1.0f', dVal) ...
            );
        
            dVal = 200;
            taskTSW = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setDecelOfWaferCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getDecelOfWaferCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TS Wafer Hydra %1.0f', dVal) ...
            );
        
            taskTSR = mic.Task(...
               'fhExecute', @() hardware.getDeltaTauPowerPmac().setDecelOfReticleCoarse(dVal), ...
               'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getDecelOfReticleCoarse() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting TS Reticle Hydra %1.0f', dVal) ...
            );
        
            ceTasks = {...
                taskTAW, ...
                taskTAR, ...
                taskTSW, ...
                taskTSR ...
            };
        
            fhGetMessage = @() [...
                'Accel set to default: ', ...
                sprintf('TA W %1.0f, ', hardware.getDeltaTauPowerPmac().getAccelOfWaferCoarse()), ...
                sprintf('TA R %1.0f, ', hardware.getDeltaTauPowerPmac().getAccelOfReticleCoarse()), ...
                sprintf('TS W %1.0f, ', hardware.getDeltaTauPowerPmac().getDecelOfWaferCoarse()), ...
                sprintf('TS R %1.0f ', hardware.getDeltaTauPowerPmac().getDecelOfReticleCoarse()) ...
            ];
        
             task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
        end
        
        function task = createStateExitSlitIsCalibrated(cName, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if  ~isa(ui, 'bl12014.ui.TuneFluxDensity')  && ...
                ~isa(ui, 'bl12014.ui.DCTFluxDensity')
                error('ui must be bl12014.ui.*FluxDensity ');
            end
            
            ceTasks = {
                mic.Task.fromUiGetSetNumberWithGoalGetter(...
                    ui.uiExitSlit.uiGap, ... mic.ui.device.GetSetNumber
                    @() ui.getGapOfExitSlitCalibrated(), ... goal getter
                    1, ... Tolerance
                    'um', ... Unit
                    'Gap of Exit Slit' ...
                ), ...
            };

               
            fhGetMessage = @() [...
                'Gap of Exit Slit @CalVal ', ...
                sprintf('(%1.1f um)', ui.getGapOfExitSlitCalibrated()) ...
            ];
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.Shutter 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateShutterIsOpen(cName, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'bl12014.ui.Shutter')
                error('ui must be bl12014.ui.Shutter');
            end
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', {...
                    mic.Task.fromUiGetSetLogical(ui.uiOverride, true, 'Shutter') ...
                }, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Shutter is open' ...
            );
            
        end
        
        
        % Returns a {mic.Task} that that does nothing on fhExecute but that
        % fhIsDone checks the LC400 to make sure that its last loaded
        % recipe matches the desired recipe and that the LC400 is
        % on/moving/scanning
        % @param {char 1xm} cName - app-wide unique name
        % @param {npoint.ui.LC400 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateMAScanningAnnular3585(cName, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'npoint.ui.LC400')
                error('ui must be npoint.ui.LC400');
            end
           
            % cNameOfRecipe = 'Annular-40-80.mat'; % testing
            cNameOfRecipe = 'Tune-Flux-Density-Ring.mat'; % testing
            
            [cDir] = fileparts(mfilename('fullpath'));
            
            cDir = mic.Utils.path2canonical(fullfile(...
                cDir, ...
                '..', ...
                'save', ...
                'scanner-ma', ...
                'starred' ...
            ));
        
            cPathOfRecipe = fullfile(...
                cDir, ...
                cNameOfRecipe ...
            );
       
            ceTasks = {...
                mic.Task(...
                   'fhIsDone', @() strcmpi(ui.getPathOfRecipe(), cPathOfRecipe), ...
                   'fhGetMessage', @() sprintf('MA recipe is %s', cPathOfRecipe) ...
                )...
                mic.Task(...
                    'fhIsDone', @() ui.uiGetSetLogicalActive.get(), ...
                    'fhGetMessage', @() 'MA is physically moving' ...
                )
            };
                
            % Return a sequence
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'MA Scanning Tune Flux Density Ring' ...
            );
        end
        
        
        % Returns a {mic.Task} that that does nothing on fhExecute but that
        % fhIsDone checks the LC400 to make sure that its last loaded
        % recipe matches the desired recipe and that the LC400 is
        % on/moving/scanning
        % @param {char 1xm} cName - app-wide unique name
        % @param {npoint.ui.LC400 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateM142ScanningDefault(cName, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'npoint.ui.LC400')
                error('ui must be npoint.ui.LC400');
            end
           
            
            [cDir] = fileparts(mfilename('fullpath'));
            
            cDir = mic.Utils.path2canonical(fullfile(...
                cDir, ...
                '..', ...
                'save', ...
                'scanner-m142', ...
                'starred' ...
            ));
        
            cPathOfRecipe = fullfile(...
                cDir, ...
                bl12014.Tasks.cRecipeM142Default ...
            );
       
            % Checks if the LC400 is loaded and if the hardware is 
            ceTasks = {...
                mic.Task(...
                   'fhIsDone', @() strcmpi(ui.getPathOfRecipe(), cPathOfRecipe), ...
                   'fhGetMessage', @() sprintf('M142 recipe is %s', cPathOfRecipe) ...
                )...
                mic.Task(...
                    'fhIsDone', @() ui.uiGetSetLogicalActive.get(), ...
                    'fhGetMessage', @() 'M142 is physically moving' ...
                )
            };
                
            % Return a sequence
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'M142 is scanning standard pattern' ...
            );
        end
        
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.Scanner 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceSetM142ToDefault(cName, uiScanner, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(uiScanner, 'bl12014.ui.Scanner')
                error('uiScanner must be bl12014.ui.Scanner');
            end
            
            % Create a task that loads a recipe into the PupilFillGenerator
            % and waits for it to populate its local buffer with the newly
            % calculated waveform from the newly loaded recipe
            
            
            task1 = mic.Task(...
                'fhExecute', @() uiScanner.uiPupilFillGenerator.setStarredByName(bl12014.Tasks.cRecipeM142Default), ...
                'fhIsDone', @() uiScanner.uiPupilFillGenerator.isDone(), ...
                'fhGetMessage', @() 'Building M142 waveform' ...
            );
         
            % Return a sequence
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', {...
                    task1, ...
                    uiScanner.uiNPointLC400.getSequenceWriteIllum() ...
                }, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Set M142 to default' ...
            );
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.Scanner 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceSetMAToAnnular3585(cName, uiScanner, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(uiScanner, 'bl12014.ui.Scanner')
                error('uiScanner must be bl12014.ui.Scanner');
            end
            
            % Create a task that loads a recipe into the PupilFillGenerator
            % and waits for it to populate its local buffer with the newly
            % calculated waveform from the newly loaded recipe
            
            % FIXME cVal in production
            cNameOfRecipe = 'Annular-40-80.mat';
            
            task1 = mic.Task(...
                'fhExecute', @() uiScanner.uiPupilFillGenerator.setStarredByName(cNameOfRecipe), ...
                'fhIsDone', @() uiScanner.uiPupilFillGenerator.isDone(), ...
                'fhGetMessage', @() 'Loading recipe into PupilFillGenerator' ...
            );
         
            % Return a sequence
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', {...
                    task1, ...
                    uiScanner.uiNPointLC400.getSequenceWriteIllum() ...
                }, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Set MA To Annular 40-80' ...
            );
        
        
            % 
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {bl12014.ui.PowerPmacWorkingMode 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceTurnOnWaferAndReticleHydra(cName, uiMotMin, uiWorkingMode, clock)
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 0, 0.1, 'mode', 'Working Mode'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui1, bl12014.Tasks.dMotMinWCX, 0.1, 'A', 'WCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui2, bl12014.Tasks.dMotMinWCY, 0.1, 'A', 'WCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui3, bl12014.Tasks.dMotMinRCX, 0.1, 'A', 'RCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui4, bl12014.Tasks.dMotMinRCY, 0.1, 'A', 'RCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 1, 0.1, 'mode', 'Working Mode') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Turn On Wafer+Reticle' ...
            );
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {bl12014.ui.PowerPmacWorkingMode 1x1}
        % @param {mic.Clock 1x1}
        
        %{
        function task = createSequenceTurnOnWaferAndReticleHydraWithHardware(cName, hardware, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            dTol = 0.1;
            
            ceTasks = {...
                mic.Task(...
                   'fhExecute', @() hardware.getDeltaTauPowerPmac().setWorkingModeUndefined(), ...
                   'fhIsDone', @() hardware.getDeltaTauPowerPmac().getActiveWorkingMode() == 0, ...
                   'fhGetMessage', @() 'Setting Working Mode 0' ...
                ), ...
                mic.Task(...
                   'fhExecute', @() hardware.getDeltaTauPowerPmac().setMotMinWaferCoarseX(bl12014.Tasks.dMotMinWCX), ...
                   'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getMotMinWaferCoarseX() - bl12014.Tasks.dMotMinWCX) < dTol, ...
                   'fhGetMessage', @() 'Setting MotMin WCX' ...
                ), ...
                mic.Task(...
                   'fhExecute', @() hardware.getDeltaTauPowerPmac().setMotMinWaferCoarseY(bl12014.Tasks.dMotMinWCY), ...
                   'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getMotMinWaferCoarseY() - bl12014.Tasks.dMotMinWCY) < dTol, ...
                   'fhGetMessage', @() 'Setting MotMin WCY' ...
                ), ...
                mic.Task(...
                   'fhExecute', @() hardware.getDeltaTauPowerPmac().setMotMinReticleCoarseX(bl12014.Tasks.dMotMinRCX), ...
                   'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getMotMinReticleCoarseX() - bl12014.Tasks.dMotMinRCX) < dTol, ...
                   'fhGetMessage', @() 'Setting MotMin RCX' ...
                ), ...
                mic.Task(...
                   'fhExecute', @() hardware.getDeltaTauPowerPmac().setMotMinReticleCoarseY(bl12014.Tasks.dMotMinRCY), ...
                   'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getMotMinReticleCoarseY() - bl12014.Tasks.dMotMinRCY) < dTol, ...
                   'fhGetMessage', @() 'Setting MotMin RCY' ...
                ), ...
                mic.Task(...
                   'fhExecute', @() hardware.getDeltaTauPowerPmac().setWorkingModeActivate(), ...
                   'fhIsDone', @() hardware.getDeltaTauPowerPmac().getActiveWorkingMode() == 1, ...
                   'fhGetMessage', @() 'Setting Working Mode 1' ...
                ), ...
            };
                    
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Turn On Wafer+Reticle' ...
            );
        end
        %}
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {bl12014.ui.PowerPmacWorkingMode 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceTurnOnWaferHydra(cName, uiMotMin, uiWorkingMode, clock)
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 0, 0.1, 'mode', 'Working Mode'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui1, bl12014.Tasks.dMotMinWCX, 0.1, 'A', 'WCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui2, bl12014.Tasks.dMotMinWCY, 0.1, 'A', 'WCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 1, 0.1, 'mode', 'Working Mode') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Turn On Wafer Hydras' ...
            );
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {bl12014.ui.PowerPmacWorkingMode 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceTurnOnReticleHydra(cName, uiMotMin, uiWorkingMode, clock)
            
            dTol = 0.1;
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 0, 0.1, 'mode', 'Working Mode'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui3, bl12014.Tasks.dMotMinRCX, dTol, 'A', 'RCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui4, bl12014.Tasks.dMotMinRCY, dTol, 'A', 'RCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 1, 0.1, 'mode', 'Working Mode') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Turn On Reticle Hydras' ...
            );
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {bl12014.ui.PowerPmacWorkingMode 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceTurnOffWaferHydra(cName, uiMotMin, uiWorkingMode, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 0, 0.1, 'mode', 'Working Mode'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui1, 0, 0.1, 'A', 'WCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui2, 0, 0.1, 'A', 'WCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 1, 0.1, 'mode', 'Working Mode') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Turn Off Wafer' ...
            );
        end
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {bl12014.ui.PowerPmacWorkingMode 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequenceTurnOffAllHydras(cName, uiMotMin, uiWorkingMode, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 0, 0.1, 'mode', 'Working Mode'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui1, 0, 0.1, 'A', 'WCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui2, 0, 0.1, 'A', 'WCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui3, 0, 0.1, 'A', 'RCX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui4, 0, 0.1, 'A', 'RCY MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui5, 0, 0.1, 'A', 'LSIX MotMin'), ...
                mic.Task.fromUiGetSetNumber(uiWorkingMode, 1, 0.1, 'mode', 'Working Mode') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Turn Off All' ...
            );
        end
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateWaferHydraOn(cName, uiMotMin, clock)
               
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui1, bl12014.Tasks.dMotMinWCX, 0.1, 'A'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui2, bl12014.Tasks.dMotMinWCY, 0.1, 'A'), ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Wafer On' ...
            );
        end
        
        
        function task = createStateHydrasOn(cName, hardware, clock)
            
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            dTol = 0.1;
            ceTasks = {...
                mic.Task(...
                   'fhIsDone', @() ...
                        abs(hardware.getDeltaTauPowerPmac().getMotMinWaferCoarseX() - bl12014.Tasks.dMotMinWCX) < dTol && ...
                        abs(hardware.getDeltaTauPowerPmac().getMotMinWaferCoarseY() - bl12014.Tasks.dMotMinWCY) < dTol && ...
                        abs(hardware.getDeltaTauPowerPmac().getMotMinReticleCoarseX() - bl12014.Tasks.dMotMinRCX) < dTol && ...
                        abs(hardware.getDeltaTauPowerPmac().getMotMinReticleCoarseY() - bl12014.Tasks.dMotMinRCY) < dTol, ...
                   'fhGetMessage', @() 'Checking Hydra MotMins' ...
                )
            };
        
        
            fhGetMessage = @() [...
                'MotMins: ', ...
                sprintf('[WX,WY,RX,RY]: '), ...
                sprintf('%1.1f, ', hardware.getDeltaTauPowerPmac().getMotMinWaferCoarseX()), ...
                sprintf('%1.1f, ', hardware.getDeltaTauPowerPmac().getMotMinWaferCoarseY()), ...
                sprintf('%1.1f, ', hardware.getDeltaTauPowerPmac().getMotMinReticleCoarseX()), ...
                sprintf('%1.1f', hardware.getDeltaTauPowerPmac().getMotMinReticleCoarseY()), ...
            ];
        
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateReticleHydraOn(cName, uiMotMin, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui3, bl12014.Tasks.dMotMinRCX, 0.1, 'A'), ...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui4, bl12014.Tasks.dMotMinRCY, 0.1, 'A'), ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Reticle On' ...
            );
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.M141 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateM141InAndD142DiodeIn(cName, uiM141, uiD142, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(uiM141, 'bl12014.ui.M141')
                error('ui must be bl12014.ui.M141');
            end
            
            if ~isa(uiD142, 'bl12014.ui.D142')
                error('ui must be bl12014.ui.D142');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiM141.uiStageX, 35.7, 0.1, 'mm'), ...
                mic.Task.fromUiGetSetNumber(uiD142.uiStageY, 88.5, 0.1, 'mm'), ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'M141 In + D142 Diode In' ...
            );
        end
        
        
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.Hardware 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateM141SmarActOff(cName, hardware, clock)
               
            
             if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
                        
            
            ceTasks = {...
                mic.Task(...
                   'fhExecute', @() ...
                        mic.Utils.evalAll(...
                            @() hardware.disconnectSmarActM141(), ... % make sure not talking to hardware
                            @() hardware.connectWebSwitchBeamline(), ... % make sure talking to webswitch
                            @() hardware.getWebSwitchBeamline().turnOffRelay1() ... % power off hardware through webswitch
                        ), ...
                   'fhIsDone', @() ...
                        hardware.getIsConnectedWebSwitchBeamline() == true && ...
                        hardware.getWebSwitchBeamline().isOnRelay1() == false, ...
                   'fhGetMessage', @() 'Removing Power From M141 SmarActMCS ...' ...
                )
            };
        
        
            fhGetMessage = @() 'M141 SmarActMCS Off (Turning off moves beam a bit)';
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.Hardware 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateVPFMOut(cName, hardware, clock)
               
            
             if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            % mm
            dX = 14.9;
            dTolX = 0.1;
            
            ceTasks = {...
                mic.Task(...
                   'fhExecute', @() hardware.getSmarActVPFM().moveAxisAbsolute(0, dX), ...
                   'fhIsDone', @() abs( hardware.getSmarActVPFM().getAxisPosition(0) - dX) < dTolX, ...
                   'fhGetMessage', @() sprintf('Moving VPFM out (%1.1f mm)', dX) ...
                )
            };
        
        
            fhGetMessage = @() 'VPFM stage is out';
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.M141 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateM141In(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'bl12014.ui.M141')
                error('ui must be bl12014.ui.M141');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiStageX, 35.7, 0.1, 'mm') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'M141 In' ...
            );
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.D142 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateD142DiodeIn(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'bl12014.ui.D142')
                error('ui must be bl12014.ui.D142');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiStageY, 88.5, 0.1, 'mm') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'D142 Diode In' ...
            );
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.PowerPmacHydraMotMin 1x1}
        % @param {mic.Clock 1x1}
        function task = createStateLsiHydraOn(cName, uiMotMin, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(uiMotMin.ui5, bl12014.Tasks.dMotMinLSI, 0.1, 'A') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'LSI On' ...
            );
        end
        
        %{
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.ReticleCoarseStage 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateReticleStageAtClearField(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
        
            if ~isa(ui, 'bl12014.ui.ReticleFiducializedMove')
                error('ui must be bl12014.ui.ReticleFiducializedMove');
            end
            
            % Fiducializatoin from 2019.04.04
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiX, 64.38, 0.1, 'mm', 'Reticle Coarse X'), ...
                mic.Task.fromUiGetSetNumber(ui.uiY, 19.785, 0.1, 'mm', 'Reticle Coarse Y'), ...
                ... %mic.Task.fromUiGetSetNumber(ui.uiZ, 0, 0.01, 'mm', 'Reticle Coarse Z') ...
            };
            
                    
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Reticle at Clear Field' ...
            );
        end
        
        %}
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {mic.ui.device.GetSetNumber 1x1} ui - get it from
        % ui.Beamline.uiGratingTiltX
        % @param {mic.Clock 1x1}
        function task = createStateMonoGratingAtEUV(...
                cName, ...
                ui, ...
                clock ...
        )
    
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'mic.ui.device.GetSetNumber')
                error('ui must be mic.ui.device.GetSetNumber');
            end
            
            dVal = 13.5;
            cUnit = 'wav (nm)';
            dTol = 0.01;
            
            task = mic.Task(...
               'fhExecute', @() ui.setDestCalDisplay(dVal, cUnit), ..., ...
               'fhIsDone', @() abs(ui.getDestCalDisplay() - dVal) < dTol, ...
               'fhGetMessage', @() sprintf('Setting Mono Grating to %1.2f nm', dVal) ...
            );
        
            % task = mic.Task.fromUiGetSetNumber(ui, 13.5, 0.01, 'wav (nm)', 'Mono Grating'), ...

            ceTasks = {...
                task
            };
                    
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() sprintf('Mono Grating at %1.2f nm', dVal) ...
            );
   
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.ReticleFiducializedMove 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateReticleStageAtClearField(...
                cName, ...
                ui, ...
                clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'bl12014.ui.ReticleFiducializedMove')
                error('ui must be bl12014.ui.ReticleFiducializedMove');
            end
            
            %{
            if ~isa(uiReticleTTZClosedLoop, 'bl12014.ui.ReticleTTZClosedLoop')
                error('uiReticleTTZClosedLoop must be bl12014.ui.ReticleTTZClosedLoop');
            end
            %}
            
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiRow, 1, 0.01, 'cell', 'Reticle to Row 1'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCol, 19, 0.01, 'cell', 'Reticle to Col 19'), ...
            };
                    
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Reticle at Clear Field' ...
            );
        end
        
        
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.WaferCoarseStage 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateWaferStageAtDiode(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiX, -103.45, 0.01, 'mm', 'Wafer Coarse X'), ...
                mic.Task.fromUiGetSetNumber(ui.uiY, 6.95, 0.01, 'mm', 'Wafer Coarse Y'), ...
                mic.Task.fromUiGetSetNumber(ui.uiZ, 0.313, 0.01, 'mm', 'Wafer Coarse Z'), ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Wafer at Diode' ...
            );
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.WaferCoarseStage 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateDCTWaferStageAtDiode(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(ui, 'bl12014.ui.DCTWaferStage')
                error('ui must be bl12014.ui.DCTWaferSTage');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiX, -130, 0.01, 'mm', 'Wafer X'), ...
                mic.Task.fromUiGetSetNumber(ui.uiY, 0, 0.01, 'mm', 'Wafer Y'), ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() 'Wafer at Diode' ...
            );
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.WaferCoarseStage 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateEndstationLEDsOff(cName, hardware, clock)
                            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            
            ceTasks = {...
                mic.Task(...
                   'fhExecute', @() hardware.getWebSwitchEndstation().turnOffRelay2(), ...
                   'fhIsDone', @() ~hardware.getWebSwitchEndstation().isOnRelay2(), ...
                   'fhGetMessage', @() 'Turning off Endstation LEDs' ...
                )
            };
        
            fhGetMessage = @() 'Endstation LEDs are OFF';
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
        end
        
        function task = createSequenceWorkingModeRunWaferPrintWaferLevel(cName, hardware, ui, clock)
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            if ~isa(ui, 'bl12014.ui.WaferTTZClosedLoop')
                error('ui must be bl12014.ui.WaferTTZClosedLoop');
            end
            
            ceTasks = {
                mic.Task( ...
                    'fhExecute', @() hardware.getDeltaTauPowerPmac().setWorkingModeRun(), ...
                    'fhIsDone', @() hardware.getDeltaTauPowerPmac().getActiveWorkingMode() == 5, ...
                    'fhAbort', @() [], ...
                    'fhGetMessage', @() sprintf('Setting WM to 5 (at %1.0f)', hardware.getDeltaTauPowerPmac().getActiveWorkingMode()) ...
                ), ...
                bl12014.Tasks.createStateWaferStageNearPrint( ...
                    [cName, 'state-wafer-stage-near-print'], ...
                    hardware, ...
                    clock ...
                ), ...
                bl12014.Tasks.createSequenceLevelWafer( ...
                    [cName, 'sequence-level-wafer'], ...
                    ui, ...
                    clock ...
                ) ...
            };
        
            fhGetMessage = @() [...
                'WM5 -> Print -> Level', ...
                sprintf('X=%1.3f ', hardware.getDeltaTauPowerPmac().getXWaferCoarse()), ...
                sprintf('Y=%1.3f ', hardware.getDeltaTauPowerPmac().getYWaferCoarse()), ...
                sprintf('Z=%1.3f', hardware.getDeltaTauPowerPmac().getZWaferCoarse()) ...
            ];
        
            fhGetMessage = @() 'WM5 -> Print -> Level';

            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.WaferCoarseStage 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateWaferStageNearPrint(cName, hardware, clock)
                            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            % mm
            dX = -5.5;
            dY = 5.5;
            dZ = 0.13;
            
            dTolX = 1;
            dTolY = 1;
            dTolZ = 0.1;
            
            
            fhIsDone = @() ...
                abs(hardware.getDeltaTauPowerPmac().getXWaferCoarse() - dX) < dTolX && ...
                abs(hardware.getDeltaTauPowerPmac().getYWaferCoarse() - dY) < dTolY && ...
                abs(hardware.getDeltaTauPowerPmac().getZWaferCoarse() - dZ) < dTolZ;
            
            %{
            fhExecute = @() ...
                 mic.Utils.evalAll(...
                    @() hardware.getDeltaTauPowerPmac().setXWaferCoarse(dX), ...
                    @() hardware.getDeltaTauPowerPmac().setYWaferCoarse(dY), ...
                    @() hardware.getDeltaTauPowerPmac().setZWaferCoarse(dZ) ...
                 );
             
            % {function_handle 1x1} called by abort()
            fhAbort = @() hardware.getDeltaTauPowerPmac().stopAll();

            % {function_handle 1x1} called by isExecuting() returns {logical 1x1}
            fhIsExecuting = @() ~hardware.getDeltaTauPowerPmac().getIsStartedWaferCoarseXYZTipTilt();

            
            ceTasks = {...
                mic.Task(...
                   'fhExecute', fhExecute, ...
                   'fhIsExecuting', fhIsExecuting, ...
                   'fhIsDone', fhIsDone, ...
                   'fhAbort', fhAbort, ...
                   'fhGetMessage', @() 'Checking WCX/Y/Z Position' ...
                )
            };
            %}
        
            ceTasks = {...
                mic.Task( ...
                    'fhExecute', @() hardware.getDeltaTauPowerPmac().setXWaferCoarse(dX), ...
                    'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getXWaferCoarse() - dX) < dTolX, ...
                    'fhAbort', @() hardware.getDeltaTauPowerPmac().stopAll(), ...
                    'fhGetMessage', @() sprintf('Setting WCX to %1.3f (at %1.3f)', dX, hardware.getDeltaTauPowerPmac().getXWaferCoarse()) ...
                ), ...
                mic.Task( ...
                    'fhExecute', @() hardware.getDeltaTauPowerPmac().setYWaferCoarse(dY), ...
                    'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getYWaferCoarse() - dY) < dTolY, ...
                    'fhAbort', @() hardware.getDeltaTauPowerPmac().stopAll(), ...
                    'fhGetMessage', @() sprintf('Setting WCY to %1.3f (at %1.3f)', dY, hardware.getDeltaTauPowerPmac().getYWaferCoarse()) ...
                ), ...
                mic.Task( ...
                    'fhExecute', @() hardware.getDeltaTauPowerPmac().setZWaferCoarse(dZ), ...
                    'fhIsDone', @() abs(hardware.getDeltaTauPowerPmac().getZWaferCoarse() - dZ) < dTolZ, ...
                    'fhAbort', @() hardware.getDeltaTauPowerPmac().stopAll(), ...
                    'fhGetMessage', @() sprintf('Setting WCZ to %1.3f (at %1.3f)', dZ, hardware.getDeltaTauPowerPmac().getZWaferCoarse()) ...
                ), ...
           };
        
        
            fhGetMessage = @() mic.Utils.ifElseLambda(...
                fhIsDone, ...
                @() [...
                    'Wafer at print? Yes! ', ...
                    sprintf('(at X=%1.3f ', hardware.getDeltaTauPowerPmac().getXWaferCoarse()), ...
                    sprintf('Y=%1.3f ', hardware.getDeltaTauPowerPmac().getYWaferCoarse()), ...
                    sprintf('Z=%1.3f)', hardware.getDeltaTauPowerPmac().getZWaferCoarse()) ...
                ], ... // returns this if the first arg returns true 
                @() [...
                    'Wafer at print? NO ', ...
                    sprintf('(at X=%1.3f ', hardware.getDeltaTauPowerPmac().getXWaferCoarse()), ...
                    sprintf('Y=%1.3f ', hardware.getDeltaTauPowerPmac().getYWaferCoarse()), ...
                    sprintf('Z=%1.3f)', hardware.getDeltaTauPowerPmac().getZWaferCoarse()) ...
                ] ... // returns this if the first arg returns false
            );

            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
        end
        
        
        
        function task = createStateDMIPowerIsOK(cName, hardware, clock)
            
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(hardware, 'bl12014.Hardware')
                error('hardware must be bl12014.Hardware');
            end
            
            
            ceTasks = {...
                mic.Task(...
                   'fhIsDone', @() ...
                        all(hardware.getMfDriftMonitor().dmiGetAxesOpticalPower() >= 1) && ...
                        all(hardware.getMfDriftMonitor().dmiGetAxesOpticalPower() <= 7) && ...
                        all(hardware.getMfDriftMonitor().dmiGetAxesOpticalPowerDC() >= 1) && ...
                        all(hardware.getMfDriftMonitor().dmiGetAxesOpticalPowerDC() <= 7), ...
                   'fhGetMessage', @() 'Checking DMI Optical Power' ...
                )
            };
        
        
            fhGetMessage = @() [...
                'DMI Power is OK ', ...
                '  AC: ', ...
                sprintf('%1.1f, ', hardware.getMfDriftMonitor().dmiGetAxesOpticalPower()), ...
                '  DC: ', ...
                sprintf('%1.1f, ', hardware.getMfDriftMonitor().dmiGetAxesOpticalPowerDC()) ...

            ];
        
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 1, ...
                'fhGetMessage', fhGetMessage ...
            );
            
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.Hardware 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateHardwareConnected(cName, ui, clock)

            ceTasks = {...
                ...mic.Task.fromUiGetSetLogical(ui.uiALS, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiMightex1, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiMightex2, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiDeltaTauPowerPmac, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiDataTranslationMeasurPoint, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiMfDriftMonitor, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiMfDriftMonitorMiddleware, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiKeithleyWafer, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiKeithleyReticle, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiWebSwitchBeamline, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiWebSwitchEndstation, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiWebSwitchVis, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiBL1201CorbaProxy, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiRigol, true), ...
                ...mic.Task.fromUiGetSetLogical(ui.uiSmarActM141, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiSmarActVPFM, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiWagoD141, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiExitSlit, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiGalilD142, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiGalilM143, true), ...
                ... This  hardware has remote power that needs to be on.
                ... the hardware class is hacked so that connecting WebSwitchVis also 
                ... turns on the first relay which powers on the Galil VIS
                mic.Task.fromUiGetSetLogical(ui.uiGalilVis, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiNPointM142, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiNPointMA, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiNewFocus8742M142, true), ...
                mic.Task.fromUiGetSetLogical(ui.uiNewFocus8742MA, true), ...
             };
         
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.25, ...
                'fhGetMessage', @() 'Connect All Hardware' ...
            );
            
        end
        
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.HeightSensorLEDs 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateHeightSensorLEDsOn(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.ui1, 850, 0.01, 'mA', 'Height Sensor LED Ch 1'), ...
                mic.Task.fromUiGetSetNumber(ui.ui2, 1000, 0.01, 'mA', 'Height Sensor LED Ch 2'), ...
                mic.Task.fromUiGetSetNumber(ui.ui3, 1000, 0.01, 'mA', 'Height Sensor LED Ch 3'), ...
                mic.Task.fromUiGetSetNumber(ui.ui4, 800, 0.01, 'mA', 'Height Sensor LED Ch 4'), ...
                mic.Task.fromUiGetSetNumber(ui.ui5, 750, 0.01, 'mA', 'Height Sensor LED Ch 5'), ...
                mic.Task.fromUiGetSetNumber(ui.ui6, 900, 0.01, 'mA', 'Height Sensor LED Ch 6') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.25, ...
                'fhGetMessage', @() 'Height Sensor LEDs On' ...
            );
        end
        
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.HeightSensorLEDs 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createStateHeightSensorLEDsOff(cName, ui, clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.ui1, 0, 0.01, 'mA', 'Height Sensor LED Ch 1'), ...
                mic.Task.fromUiGetSetNumber(ui.ui2, 0, 0.01, 'mA', 'Height Sensor LED Ch 2'), ...
                mic.Task.fromUiGetSetNumber(ui.ui3, 0, 0.01, 'mA', 'Height Sensor LED Ch 3'), ...
                mic.Task.fromUiGetSetNumber(ui.ui4, 0, 0.01, 'mA', 'Height Sensor LED Ch 4'), ...
                mic.Task.fromUiGetSetNumber(ui.ui5, 0, 0.01, 'mA', 'Height Sensor LED Ch 5'), ...
                mic.Task.fromUiGetSetNumber(ui.ui6, 0, 0.01, 'mA', 'Height Sensor LED Ch 6') ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.25, ...
                'fhGetMessage', @() 'Height Sensor LEDs Off' ...
            );
        end
        
        % Sequence that:
        % - reticle at clear field
        % - wafer at diode
        % - height sensor LEDs off
        % - shutter open
        % - MA scanning annular 35/85
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.ReticleFiducializedMove 1x1}
        % @param {bl12014.ui.WaferCoarseStage 1x1}
        % @param {bl12014.ui.WaferCoarseStage 1x1}
        % @param {mic.Clock 1x1}
        function task = createSequencePrepForTuningFluxDensity(...
                cName, ...
                uiReticle, ...
                uiReticleTTZClosedLoop, ...
                uiWafer, ...
                uiLEDs, ...
                uiScannerMA, ...
                uiScannerM142, ...
                uiShutter, ...
                clock)
                
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            if ~isa(uiReticle, 'bl12014.ui.ReticleFiducializedMove')
                error('uiReticle must be bl12014.ui.ReticleFiducializedMove');
            end
            
            if ~isa(uiReticleTTZClosedLoop, 'bl12014.ui.ReticleTTZClosedLoop')
                error('uiReticleTTZClosedLoop must be bl12014.uiReticleTTZClosedLoop');
            end
            
            if ~isa(uiWafer, 'bl12014.ui.WaferCoarseStage')
                error('uiWafer must be bl12014.ui.WaferCoarseStage');
            end
            
            if ~isa(uiLEDs, 'bl12014.ui.HeightSensorLEDs')
                error('uiLEDs must be bl12014.ui.HeightSensorLEDs');
            end
            
            if ~isa(uiScannerMA, 'bl12014.ui.Scanner')
                error('uiScannerMA must be bl12014.ui.Scanner');
            end
            
            if ~isa(uiScannerM142, 'bl12014.ui.Scanner')
                error('uiScannerM142 must be bl12014.ui.Scanner');
            end
            
            if ~isa(uiShutter, 'bl12014.ui.Shutter')
                error('uiShutter must be bl12014.ui.Shutter');
            end
            
            ceTasks = {...
                bl12014.Tasks.createStateReticleStageAtClearField(...
                    [cName, 'reticle-stage-at-clear-field'], ...
                    uiReticle, ...
                    clock ...
                ), ...
                bl12014.Tasks.createSequenceLevelReticle(...
                    [cName, 'reticle-is-level'], ...
                    uiReticleTTZClosedLoop, ...
                    clock ...
                ), ...
                bl12014.Tasks.createStateWaferStageAtDiode(...
                    [cName, 'wafer-stage-at-diode'], ...
                    uiWafer, ...
                    clock ...
                ), ...
                bl12014.Tasks.createStateHeightSensorLEDsOff(...
                    [cName, 'height-sensor-leds-off'], ...
                    uiLEDs, ...
                    clock ...
                ), ...
                bl12014.Tasks.createSequenceSetMAToAnnular3585(...
                    [cName, 'set-ma-to-annular-3585'], ...
                    uiScannerMA, ...
                    clock ...
                ), ...
                bl12014.Tasks.createSequenceSetM142ToDefault(...
                    [cName, 'set-m142-to-default'], ...
                    uiScannerM142, ...
                    clock ...
                ), ...
                bl12014.Tasks.createStateShutterIsOpen(...
                    [cName, 'shutter-is-open'], ...
                    uiShutter, ...
                    clock ...
                ), ...
            };
            
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.1, ...
                'fhGetMessage', @() 'Prep Reticle, Wafer, HS LEDs, Shutter, M142 Scan, MA Scan' ...
            );
        end
        
        
        % Sequence that:
        % - Sets wafer rx, ry, and z based on config data
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.WaferTTZClosedLoop 1x1} ui
        % @param {mic.Clock 1x1}
        function task = createSequenceLevelWafer(...
                cName, ...
                ui, ...
                ...uiHeightSensorLEDs, ...
                clock)
                
            
            if ~isa(ui, 'bl12014.ui.WaferTTZClosedLoop')
                error('ui must be bl12014.ui.WaferTTZClosedLoop');
            end
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            cDirThis = fileparts(mfilename('fullpath'));
            cPathConfig = fullfile(...
                cDirThis, ...
                '..', ...
                'config', ...
                'Wafer-CLTTZ-leveler-coordinates.json' ...
            );
            % stConfigDat = loadjson(cPathConfig);
            
            fid = fopen(cPathConfig, 'r');
            cText = fread(fid, inf, 'uint8=>char');
            fclose(fid);
            stConfigDat = jsondecode(cText');
            
            %{
            I had debated on making it turn on the HS LEDs but decided
            against it
            bl12014.Tasks.createStateHeightSensorLEDsOn(...
                [cName, 'height-sensor-leds-on'], ...
                uiHeightSensorLEDs, ...
                clock ...
            ), ...
            %}

            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiCLZ, ...
                    stConfigDat.Z.value, ...
                    stConfigDat.Z.displayTol, ...
                    stConfigDat.Z.unit, ...
                    'HS Simple Z'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCLTiltX, ...
                    stConfigDat.tiltX.value, ...
                    stConfigDat.tiltX.displayTol, ...
                    stConfigDat.tiltX.unit, ...
                    'HS Tilt X'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCLTiltY, ...
                    stConfigDat.tiltY.value, ...
                    stConfigDat.tiltY.displayTol, ...
                    stConfigDat.tiltY.unit, ...
                    'HS Tilt Y'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCLZ, ...
                    stConfigDat.Z.value, ...
                    stConfigDat.Z.displayTol, ...
                    stConfigDat.Z.unit, ...
                    'HS Simple Z'), ...
            };
            
            fhGetMessage = sprintf('Level Wafer (x %1.0fum +/- 30, y %1.0fum +/- 30, z %1.0fnm +/- 1000)', ...
                stConfigDat.tiltX.value, ...
                stConfigDat.tiltY.value, ...
                stConfigDat.Z.value ...
            );
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() fhGetMessage ...
            );
        end
        
         % Sequence that:
        % - Sets RETICLE rx, ry, and z based on config data
        % @param {char 1xm} cName - app-wide unique name
        % @param {bl12014.ui.ReticleTTZClosedLoop} ui
        % @param {mic.Clock 1x1}
        function task = createSequenceLevelReticle(...
                cName, ...
                ui, ...
                clock)
               
            if ~isa(ui, 'bl12014.ui.ReticleTTZClosedLoop')
                error('ui must be bl12014.ui.ReticleTTZClosedLoop');
            end
            
            if ~isa(clock, 'mic.Clock')
                error('clock must be mic.Clock');
            end
            
            
            cDirThis = fileparts(mfilename('fullpath'));
            cPathConfig = fullfile(...
                cDirThis, ...
                '..', ...
                'config', ...
                'Reticle-CLTTZ-leveler-coordinates.json' ...
            );
            % stConfigDat = loadjson(cPathConfig);
            
            fid = fopen(cPathConfig, 'r');
            cText = fread(fid, inf, 'uint8=>char');
            fclose(fid);
            stConfigDat = jsondecode(cText');

            ceTasks = {...
                mic.Task.fromUiGetSetNumber(ui.uiCLZ, ...
                    stConfigDat.Z.value, ...
                    stConfigDat.Z.displayTol, ...
                    stConfigDat.Z.unit, ...
                    'Ret Z'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCLTiltX, ...
                    stConfigDat.tiltX.value, ...
                    stConfigDat.tiltX.displayTol, ...
                    stConfigDat.tiltX.unit, ...
                    'Ret Tilt X'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCLTiltY, ...
                    stConfigDat.tiltY.value, ...
                    stConfigDat.tiltY.displayTol, ...
                    stConfigDat.tiltY.unit, ...
                    'Ret Tilt Y'), ...
                mic.Task.fromUiGetSetNumber(ui.uiCLZ, ...
                    stConfigDat.Z.value, ...
                    stConfigDat.Z.displayTol, ...
                    stConfigDat.Z.unit, ...
                    'Ret Z') ...
            };
            
            fhGetMessage = sprintf('Level Reticle (x %1.0fum, y %1.0fum, z %1.0fnm)', ...
                stConfigDat.tiltX.value, ...
                stConfigDat.tiltY.value, ...
                stConfigDat.Z.value ...
            );
            task = mic.TaskSequence(...
                'cName', cName, ...
                'clock', clock, ...
                'ceTasks', ceTasks, ...
                'dPeriod', 0.5, ...
                'fhGetMessage', @() fhGetMessage ...
            );
        end
    end 
    
    
end